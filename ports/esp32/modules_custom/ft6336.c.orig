#include "py/obj.h"
#include "py/runtime.h"
#include "py/mphal.h"
#include "driver/i2c.h"
#include "esp_log.h"

static const char *TAG = "FT6336";

// FT6336 I2C Address and Registers
#define FT6336_ADDR           0x38
#define FT6336_REG_NUM_TOUCHES 0x02
#define FT6336_REG_TOUCH1_XH  0x03
#define FT6336_REG_TOUCH1_XL  0x04
#define FT6336_REG_TOUCH1_YH  0x05
#define FT6336_REG_TOUCH1_YL  0x06
#define FT6336_REG_CHIPID     0xA3
#define FT6336_REG_FIRMID     0xA6

// Global I2C configuration
static i2c_port_t i2c_port = I2C_NUM_0;
static bool initialized = false;

// Read register with error handling
static esp_err_t ft6336_read_reg(uint8_t reg, uint8_t *data) {
    if (!initialized) {
        return ESP_FAIL;
    }
    
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    if (cmd == NULL) {
        return ESP_FAIL;
    }
    
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (FT6336_ADDR << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg, true);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (FT6336_ADDR << 1) | I2C_MASTER_READ, true);
    i2c_master_read_byte(cmd, data, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(i2c_port, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    
    return ret;
}

// Deinitialize touch controller
static mp_obj_t ft6336_deinit(void) {
    if (initialized) {
        ESP_LOGI(TAG, "Deinitializing FT6336...");
        
        esp_err_t ret = i2c_driver_delete(i2c_port);
        if (ret == ESP_OK) {
            ESP_LOGI(TAG, "I2C driver removed successfully");
            initialized = false;
        } else {
            ESP_LOGW(TAG, "Failed to remove I2C driver: %d", ret);
            // Still mark as not initialized to allow retry
            initialized = false;
        }
    }
    
    return mp_const_none;
}
static MP_DEFINE_CONST_FUN_OBJ_0(ft6336_deinit_obj, ft6336_deinit);

// Initialize touch controller
static mp_obj_t ft6336_init(size_t n_args, const mp_obj_t *args) {
    // args: i2c_port, sda_pin, scl_pin, freq
    i2c_port = mp_obj_get_int(args[0]);
    int sda_pin = mp_obj_get_int(args[1]);
    int scl_pin = mp_obj_get_int(args[2]);
    int freq = (n_args > 3) ? mp_obj_get_int(args[3]) : 100000;
    
    ESP_LOGI(TAG, "Initializing FT6336: I2C%d, SDA=%d, SCL=%d, freq=%d", 
             i2c_port, sda_pin, scl_pin, freq);
    
    // If already initialized, deinitialize first
    if (initialized) {
        ESP_LOGW(TAG, "Already initialized, deinitializing first...");
        ft6336_deinit();
        vTaskDelay(pdMS_TO_TICKS(100)); // Give time for cleanup
    }
    
    // Try to delete driver in case it wasn't cleaned up properly
    i2c_driver_delete(i2c_port); // Ignore errors
    vTaskDelay(pdMS_TO_TICKS(50));
    
    // Configure I2C
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = sda_pin,
        .scl_io_num = scl_pin,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = freq,
        .clk_flags = 0,
    };
    
    esp_err_t ret = i2c_param_config(i2c_port, &conf);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "I2C param config failed: %d", ret);
        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT("I2C config failed"));
    }
    
    ret = i2c_driver_install(i2c_port, conf.mode, 0, 0, 0);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "I2C driver install failed: %d", ret);
        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT("I2C driver install failed"));
    }
    
    initialized = true;
    
    // Verify chip ID
    uint8_t chip_id = 0;
    uint8_t firm_id = 0;
    
    ret = ft6336_read_reg(FT6336_REG_CHIPID, &chip_id);
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "Failed to read chip ID: %d", ret);
        chip_id = 0;
    }
    
    ret = ft6336_read_reg(FT6336_REG_FIRMID, &firm_id);
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "Failed to read firmware ID: %d", ret);
        firm_id = 0;
    }
    
    ESP_LOGI(TAG, "FT6336 initialized. Chip ID: 0x%02X, Firmware ID: 0x%02X", chip_id, firm_id);
    
    // Return tuple with chip info
    mp_obj_t tuple[2] = {
        mp_obj_new_int(chip_id),
        mp_obj_new_int(firm_id)
    };
    return mp_obj_new_tuple(2, tuple);
}
static MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(ft6336_init_obj, 3, 4, ft6336_init);

// Check if initialized
static mp_obj_t ft6336_is_initialized(void) {
    return mp_obj_new_bool(initialized);
}
static MP_DEFINE_CONST_FUN_OBJ_0(ft6336_is_initialized_obj, ft6336_is_initialized);

// Read touch data
static mp_obj_t ft6336_read_touch(void) {
    if (!initialized) {
        // Return no touch instead of raising error
        mp_obj_t tuple[3] = {
            mp_obj_new_bool(false),
            mp_obj_new_int(0),
            mp_obj_new_int(0)
        };
        return mp_obj_new_tuple(3, tuple);
    }
    
    // Read number of touches
    uint8_t num_touches = 0;
    esp_err_t ret = ft6336_read_reg(FT6336_REG_NUM_TOUCHES, &num_touches);
    
    if (ret != ESP_OK || num_touches == 0 || num_touches > 2) {
        // No touch or invalid data
        mp_obj_t tuple[3] = {
            mp_obj_new_bool(false),
            mp_obj_new_int(0),
            mp_obj_new_int(0)
        };
        return mp_obj_new_tuple(3, tuple);
    }
    
    // Read touch coordinates
    uint8_t xh = 0, xl = 0, yh = 0, yl = 0;
    
    if (ft6336_read_reg(FT6336_REG_TOUCH1_XH, &xh) != ESP_OK ||
        ft6336_read_reg(FT6336_REG_TOUCH1_XL, &xl) != ESP_OK ||
        ft6336_read_reg(FT6336_REG_TOUCH1_YH, &yh) != ESP_OK ||
        ft6336_read_reg(FT6336_REG_TOUCH1_YL, &yl) != ESP_OK) {
        
        // Read error
        mp_obj_t tuple[3] = {
            mp_obj_new_bool(false),
            mp_obj_new_int(0),
            mp_obj_new_int(0)
        };
        return mp_obj_new_tuple(3, tuple);
    }
    
    // Combine bytes to get coordinates
    int x = ((xh & 0x0F) << 8) | xl;
    int y = ((yh & 0x0F) << 8) | yl;
    
    // Return tuple (touched, x, y)
    mp_obj_t tuple[3] = {
        mp_obj_new_bool(true),
        mp_obj_new_int(x),
        mp_obj_new_int(y)
    };
    return mp_obj_new_tuple(3, tuple);
}
static MP_DEFINE_CONST_FUN_OBJ_0(ft6336_read_touch_obj, ft6336_read_touch);

// Get number of touches
static mp_obj_t ft6336_get_touches(void) {
    if (!initialized) {
        return mp_obj_new_int(0);
    }
    
    uint8_t num_touches = 0;
    esp_err_t ret = ft6336_read_reg(FT6336_REG_NUM_TOUCHES, &num_touches);
    
    if (ret != ESP_OK) {
        return mp_obj_new_int(0);
    }
    
    return mp_obj_new_int(num_touches);
}
static MP_DEFINE_CONST_FUN_OBJ_0(ft6336_get_touches_obj, ft6336_get_touches);

// Module globals
static const mp_rom_map_elem_t ft6336_module_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ft6336) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&ft6336_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&ft6336_deinit_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_initialized), MP_ROM_PTR(&ft6336_is_initialized_obj) },
    { MP_ROM_QSTR(MP_QSTR_read_touch), MP_ROM_PTR(&ft6336_read_touch_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_touches), MP_ROM_PTR(&ft6336_get_touches_obj) },
};
static MP_DEFINE_CONST_DICT(ft6336_module_globals, ft6336_module_globals_table);

const mp_obj_module_t ft6336_module = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&ft6336_module_globals,
};

MP_REGISTER_MODULE(MP_QSTR_ft6336, ft6336_module);

